#include <linux/kfuzztest.h>
#include <net/netlink.h>

// A buffer for the fuzzer to write raw netlink attribute data into.
#define FUZZ_DATA_SIZE 4096

// Our custom attribute types for this test.
enum {
	MY_ATTR_UNSPEC,
	MY_ATTR_U32,
	MY_ATTR_STRING,
	__MY_ATTR_MAX,
};

// The maximum attribute number.
#define MY_ATTR_MAX (__MY_ATTR_MAX - 1)

// The validation policy that nla_parse will use.
// This tells the parser what to expect for each attribute type.
static const struct nla_policy my_policy[MY_ATTR_MAX + 1] = {
	[MY_ATTR_U32] = { .type = NLA_U32 }, // Expect a 4-byte unsigned integer.
	[MY_ATTR_STRING] = { .type = NLA_STRING, .len = 64 }, // Expect a string up to 64 chars.
};

struct nla_parse_arg {
	// The length of the data in the buffer. The fuzzer will vary this.
	size_t len;
	// The raw byte stream of nlattr's. The fuzzer will fill this with data.
	// This corresponds to the `head` parameter.
	char data[FUZZ_DATA_SIZE];
};

// --- Step 3: Write the complete fuzz target ---

FUZZ_TEST(test_nla_parse, struct nla_parse_arg)
{
	// This is the output parameter `tb`. Its size is based on `maxtype`.
	// nla_parse will populate this array with pointers into arg->data.
	struct nlattr *tb[MY_ATTR_MAX + 1];
	KFUZZTEST_EXPECT_LE(nla_parse_arg, len, FUZZ_DATA_SIZE);

	// The core of the test: parse the fuzzer's data using our policy.
	// The return value isn't critical; we are looking for crashes (KASAN, etc.).
	nla_parse(tb, // Output: The destination table for pointers.
		  MY_ATTR_MAX, // Context: The highest attribute type we expect.
		  (const struct nlattr *)arg->data, // Input: The fuzzer-generated byte stream.
		  arg->len, // Input: The length of the byte stream.
		  my_policy, // Context: The validation rules.
		  NULL); // Context: No extended ACK needed.
}
